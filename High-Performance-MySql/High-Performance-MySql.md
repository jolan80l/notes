

# 第5章 创建高性能的索引

## 索引基础

如果索引包含多个列，那么列的顺序也十分重要，因为MySQL只能高效地使用索引的最左前缀列。创建一个包含两个列的索引，和创建两个之包含一列的索引是大不相同的。

### 索引的类型

在MySQl中，索引是在存储引擎层面二不是服务器层实现的。所以，并没有统一的索引标准：不同存储引擎的索引的工作方式并不一样，也不是所有的存储引擎都支持所有类型的索引。即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。

#### B-Tree索引

底层的存储引擎也可能使用不同的存储结构，例如，NDB集群存储引擎内部实际上使用了T-Tree结构存储这种索引，即使其名字是BTREE；InnoDB则使用的是B+Tree。

B-Tree通常意味着所有的值都是按顺序存储的，并且每一个叶子到根的距离相同。

![avatar](img/1.jpeg)

B-Tree对索引列是顺序组织存储的，所以很适合查找范围数据。

索引对多个值进行排序的一局是CREATE TABLE语文中定义索引时列的顺序。B-Tree索引适用于全键值、键值范围或键前缀查找。其中键前缀查找只适用于根据最左前缀的查找。索引对如下类型的查询有效：1.全值匹配；2.匹配最左前缀；3.匹配范围值；4.精确匹配某一列并范围匹配另外一列；5.只访问索引的查询（覆盖索引）。

因为索引树中的节点是有序的，所以除了按值查找之外，索引还可以用于查询中的ORDER BY操作。所以，如果ORDER BY子句满足前面列出的几种查询类型，则这个索引也可以满足对应的排序需求。

下面是一些关于B-Tree索引的限制：

- 如果不是按照索引的最左列开始查找，则无法使用索引。

- 不能跳过索引的列。

- 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。例如有查询WHERE last_name = 'Smith' AND first_name  LIKE 'J%' AND dob = '1976-12-23'

#### 哈希索引

在MySQL中，只有Memory引擎显示支持哈希索引。

#### 全文索引

全文索引它查找的是文本中的关键词，而不是直接比较索引中的值。在相同的列上同时创建全文索引和基于值的B-Tree索引不会有冲突，全文索引适用于MATCH AGINST操作，而不是普通的WHERE条件操作。

## 索引的优点

索引有如下三个有点：

- 索引大大减少了服务器需要扫描的数据量；

- 索引可以帮助服务器避免排序和临时表；

- 索引可以将随机I/O变为顺序I/O

当索引帮助存储引擎快速查找到记录带来的好处大于其带来的额外工作时，索引才是有效的。

## 高性能的索引策略

### 独立的列

“独立的列”是指索引列不能是表达式的一部分，也不能是函数的参数。如这个查询无法使用actor_id列的索引：SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;

### 前缀索引和索引选择性

索引的选择性是指，不重复的索引值（也成为基数，cardinality）和数据表的记录总数（#T）的比值。索引的选择性越高则查询效率越高，因为选择性高的索引可以让MySQL在查询时过滤掉更多的行。唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。

一般情况下某个列前缀的选择性也是足够高的，足以满足查询性能。对于BLOB、TEXT或者很长的VARCHAR类型的列，必须使用前缀索引，因为MySQL不允许索引这些列的完整长度。

为了决定前缀的合适长度，需要找到最常见的值的列表，然后和最常见的前缀列表进行比较。

计算合适的前缀长度的另外一个办法就是计算完整的列的选择性，并使用前缀的选择性接近于完整列的选择性。

```sql
SELECT COUNT(DISTINCT city)/COUNT(*) FROM sakila.city_demo;
```

这个例子中如果前缀的选择性能够接近0.031，基本上就可用了。

平均选择性会让你认为前缀长度为4或5的索引已经足够足够了，但如果数据不均匀，可能就会有陷阱。例如在真实的城市名上建一个长度为4的前缀索引，对于以“San”和“New”开头的城市的选择性就会非常糟糕，因为很多城市都以这两个词开头。如何创建前缀索引：ALTER TABLE sakila.city_demo ADD KEY (city(7));

前缀索引是一种能使索引更小、更快的有效办法，但另一方面也有其缺点：MySQL无法使用前缀索引做ORDER BY和GROUP BY，也无法使用前缀索引做覆盖扫描。一个常见的场景是针对很长的十六进制唯一ID使用前缀索引。

### 多列索引

在多个列上建立独立的单列索引大部分情况下并不能提高MySQL的查询性能。例如，表film_actor在字段film_id和actor_id上各有一个索引，但对于下面这个查询WHERE条件，这两个单列索引都不是好的选择：SELECT film_id, actor_id FROM sakila.film_actor WHERE actor_id = 1 OR film_id = 1;除非修改为SELECT film_id, actor FROM sakila.film_actor WHERE actor_id = 1 UNION ALL SELECT film_id, actor FROM sakila.film_actor WHERE actor_id = 1 AND actor_id <> 1;在MySQL5.0和更新的版本中，查询能够同时使用这两个单列索引进行扫描，并将结果进行合并。这种算法有三个变种：OR条件的联合（union），AND条件的相交（intersection），组合前两种情况的联合及相交。

### 选择合适的索引列顺序

正确的顺序依赖于使用该索引的查询，并且同时需要考虑如何更好地满足排序和分组的需要。在一个多列B-Tree索引中，索引列的顺序意味着索引首先按照最左列进行排序，其次是第二列，等等。所以，索引可以按照升序或者降序进行扫描，以满足精确符合列顺序的ORDER BY、GROUP BY和DISTINCT等字句的查询要求。

将选择性最高的列放到索引最前列。但通常不如避免随机IO和排序那么重要。然而，性能不只是依赖于所有索引列的选择性（整体基数），也和查询条件的具体值有关，也就是和值的分布有关。

```sql
SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity, COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity, COUNT(*) FROM payment;
```

### 聚簇索引

InnoDB的聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行。当表有聚簇索引时，它的数据行实际上存放在索引的叶子页（leaf page）中。因为无法同时把数据行存放在两个不同的地方，所以一个表只能由一个聚簇索引。

如果没有主键，InnoDB会选择一个唯一的非空索引代替。如果没有这样的索引，InnoDB会隐式定义一个主键来作为聚簇索引。

聚簇索引有一些重要的优点：

- 可以把相关数据保存在一起。

- 数据访问更快。聚簇索引将索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取数据通常比非聚簇索引中查找要快。

- 使用覆盖索引扫描的查询可以直接使用页节点中的主键值。

同时，聚簇索引也有一些缺点：

- 聚簇索引最大限度地提高了I/O密集型应用的性能，但如果数据全部都放在内存中，则访问的顺序就没有那么重要了，聚簇索引也就没什么优势了。

- 插入速度严重依赖于插入的顺序。按照主键的顺序插入是加载数据到InnoDB表中速度最快的方式。

- 更新聚簇索引的代价很高，因为会强制InnoDB将每个更新的行移动道新的位置。

- 聚于聚簇索引的表在插入行，或者主键被更新导致需要移动行的时候，可能面临“页分裂（page split）”的问题。当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页来容纳该行，这就是页分裂操作。页分裂会导致表占用更多的磁盘空间。

- 聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于也分裂导致数据存储不连续时。

- 二级索引（非聚簇索引）可能比想象的要更大，因为二级索引的叶子节点包含了引用行的主键列。

- 二级索引访问需要两次索引查找，而不是一次。

二级索引页字节点保存的不是指向行的物理位置的指针，而是行的主键值。这意味着通过二级索引查找行，存储引擎需要找到二级索引的叶子节点获得对应的主键值，然后根据这个值去聚簇索引中查找到对应的行。这里做了重复的工作：两次B-Tree查找而不是一次。

#### InnoDB和MyISAM的数据分布对比

MyISAM的行号从0开始递增。以为行是定长的，所以MyISAM可以从表的开头跳过所需的字节找到需要的行。索引中的每个叶子结点包含“行号”。

事实上，MyISAM中主键索引和其他索引再结构上没有什么不同。主键索引就是一个名称为PRIMARY的唯一非空索引。

因为InnoDB支持聚簇索引，所以使用非常不同的方式存储同样的数据。聚簇索引的每一个叶子节点都包含了主键值、事物ID、用于事物和MVCC的回滚指针以及所有的剩余列。如果主键是一个列前缀索引，InnoDB也会包含完整的主键列和剩下的其他列。

InnoDB二级索引的叶子节点中存储的不是“行指针”，而是主键值，并以此作为指向行的“指针”。这样的策略减少了当出现行移动或者数据页分裂时二级索引的维护工作。使用主键值当作指针会让二级索引占用更多的空间，换来的好处是，InnoDB再移动行时无须更新二级索引的这个“指针”。

![avatar](img/2.png)

#### 在InnoDB表中按主键顺序插入行

在InnoDB表中，可以定义一个代理键作为主键，这种主键的数据应该和应用无关，最简单的方法是使用AUTO_INCREMENT自增列。这样可以保证数据行是按顺序写入的。

应该避免随机的聚簇索引，这会增加很多额外的工作，并且导致数据分布不够优化。下面是总结的一些缺点：

- 写入的目标页可能已经刷到磁盘上并从缓存中移除，或者是还没有被加载到缓存中，InnoDB在插入之前不得不先找到并从磁盘读取目标页到内存中。这将导致大量的随机I/O。

- 因为写入是乱序的，InnoDB不得不频繁地做页分裂操作，以便为新的行分配空间。页分裂会导致移动大量数据，一次插入最少需要修改三个页而不是一个页。

- 由于频繁的页分裂，页会变得稀疏并被不规则地填充，所以最终数据会有碎片。

对于高并发的工作负载，在InnoDB中按顺序插入可能会造成明显的征用。所以并发插入可能导致间隙锁竞争。这种情况可以考虑修改innodb_autoinc_lock_mode配置（版本支持的话）。

