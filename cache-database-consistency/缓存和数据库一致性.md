# 说明

​	探讨何种情况会产生缓存和数据库的不一致，并且有哪些解决方案。

# 先操作缓存和先操作数据库分别会产生哪些问题

​	假设：A线程更新，B线程读取

## 先删除redis，再更新数据库
​	1.线程A删除redis
​	2.线程B读取redis未读取到数据，读取数据库
​	3.线程B将数据写入redis
​	4.线程A将新值更新到数据库

​	最终redis是A线程读取的旧值，数据库是B线程更新的新值，此时redis和数据库不一致

## 先更新数据库，再删除redis
​	1.假设缓存失效了
​	2.线程B读取redis未获取到数据，从数据库读取旧值
​	3.线程A将新值更新到数据库
​	4.线程A删除缓存
​	5.线程B将旧值写入缓存

​	最终数据库是A线程写入的新值，redis是B线程更新的旧值，此时redis和数据库不一致

# 解决方案

## 队列存储请求

​	凡是遇到写请求，则将写请求放入队列中，由队列对写请求统一管理，写请求处理成功，则从队列中删除。当有一个读请求过来时，到队列查询，是否有对应的写请求，如果有则放入队列中，等待写请求执行完之后再执行读请求。为防止某个请求阻塞情况，为其设置超时机制或者过期机制。

​	具体举例说明：创建几个队列，如20个，根据商品的ID去做hash值，然后对队列个数取摸，当有数据更新请求时，先把它丢到队列里去，当更新完后在从队列里去除，如果在更新的过程中，遇到以上场景，先去缓存里看下有没有数据，如果没有，可以先去队列里看是否有相同商品ID在做更新，如果有也把查询的请求发送到队列里去，然后同步等待缓存更新完成。这里有一个优化点，如果发现队列里有一个查询请求了，那么就不要放新的查询操作进去了，用一个while（true）循环去查询缓存，循环个200MS左右，如果缓存里还没有则直接取数据库的旧数据，一般情况下是可以取到的
### 可能遇到的问题

​	（1）读请求时长阻塞：由于读请求进行了非常轻度的异步化，所以一定要注意读超时的问题，每个读请求必须在超时间内返回，该解决方案最大的风险在于可能数据更新很频繁，导致队列中挤压了大量的更新操作在里面，然后读请求会发生大量的超时，最后导致大量的请求直接走数据库，像遇到这种情况，一般要做好足够的压力测试，如果压力过大，需要根据实际情况添加机器。
​	（2）请求并发量过高问题：这里还是要做好压力测试，多模拟真实场景，并发量在最高的时候QPS多少，扛不住就要多加机器，还有就是做好读写比例是多少
​	（3）多服务实例部署的请求路由：可能这个服务部署了多个实例，那么必须保证说，执行数据更新操作，以及执行缓存更新操作的请求，都通过nginx服务器路由到相同的服务实例上
​	（4）热点商品的路由问题：导致请求的倾斜某些商品的读请求特别高，全部打到了相同的机器的相同丢列里了，可能造成某台服务器压力过大，因为只有在商品数据更新的时候才会清空缓存，然后才会导致读写并发，所以更新频率不是太高的话，这个问题的影响并不是很大，但是确实有可能某些服务器的负载会高一些。

## 读写分离

​	读请求只访问缓存，写请求只修改数据库和缓存。写请求修改数据库和缓存是事务性动作，如果更新数据库成功，更新缓存失败，则回滚数据库，保证缓存与数据库数据强一致。这样实现了读写分离，不仅提高了读的响应速度，由写请求负责缓存与数据库一致，只有写请求成功才会影响到缓存的内容，时效性大大增强。

### 可能遇到的问题

​	这种解决方案依然会遇到上面的第二个问题——即先更新数据库，再删除redis的问题（缓存失效）

# 参考资料

​	https://blog.csdn.net/simba_1986/article/details/77823309

# 总结

​	没有最好的方案，只有最优的方案。需要多方面考察，比如读写比例，并发量，响应时长的要求等等。

